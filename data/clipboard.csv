timestamp,content,window_title,process,pid
2025-10-04 18:34:01,"2025-10-04 17:28:22,copy,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 17:28:22\r\n2025-10-04 17:28:25,paste,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 17:28:25\r\n2025-10-04 17:40:19,copy,ProcessBot automation hackathon – Opera,opera.exe,18264,2025-10-04 17:40:19\r\n2025-10-04 17:40:35,paste,Submit a new project | ChallengeRocket.com – Opera,opera.exe,18264,2025-10-04 17:40:35\r\n2025-10-04 17:43:08,copy,summarise - Szukaj w Google – Opera,opera.exe,18264,2025-10-04 17:43:08\r\n2025-10-04 17:43:12,paste,Submit a new project | ChallengeRocket.com – Opera,opera.exe,18264,2025-10-04 17:43:12\r\n2025-10-04 17:44:42,copy,ProcessBot automation hackathon – Opera,opera.exe,18264,2025-10-04 17:44:42\r\n2025-10-04 17:44:47,paste,Submit a new project | ChallengeRocket.com – Opera,opera.exe,18264,2025-10-04 17:44:47\r\n2025-10-04 17:45:53,copy,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 17:45:53\r\n2025-10-04 18:05:29,copy,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 18:05:29\r\n2025-10-04 18:05:31,copy,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 18:05:31\r\n2025-10-04 18:20:21,copy,Command Prompt - app.py,WindowsTerminal.exe,10672,2025-10-04 18:20:21\r\n2025-10-04 18:22:29,copy,events.csv - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 18:22:29\r\n2025-10-04 18:24:48,copy,APP.PY - Hackaton - Visual Studio Code,Code.exe,18256,2025-10-04 18:24:48\r\n",Command Prompt - app.py,WindowsTerminal.exe,16848
2025-10-04 18:35:50,"def plot_process_network(self, output_html: str = None):\r\n        """"""Tworzy interaktywny wykres sieci przejść między procesami.""""""\r\n        df = self.data.copy()\r\n        df['next_process'] = df['process'].shift(-1)\r\n        \r\n        # usuwamy powtarzające się procesy z rzędu (brak ""przejścia"")\r\n        df = df[df['process'] != df['next_process']]\r\n        \r\n        # liczba przejść między procesami\r\n        transitions = df.groupby(['process', 'next_process']).size().reset_index(name='count')\r\n        \r\n        # budowa grafu NetworkX\r\n        G = nx.DiGraph()\r\n        for _, row in transitions.iterrows():\r\n            G.add_edge(row['process'], row['next_process'], weight=row['count'])\r\n        \r\n        pos = nx.spring_layout(G, seed=42)  # rozmieszczenie węzłów\r\n        \r\n        # przygotowanie danych do Plotly\r\n        edge_x, edge_y = [], []\r\n        for edge in G.edges():\r\n            x0, y0 = pos[edge[0]]\r\n            x1, y1 = pos[edge[1]]\r\n            edge_x.extend([x0, x1, None])\r\n            edge_y.extend([y0, y1, None])\r\n        \r\n        edge_trace = go.Scatter(\r\n            x=edge_x, y=edge_y,\r\n            line=dict(width=1, color='#888'),\r\n            hoverinfo='none',\r\n            mode='lines'\r\n        )\r\n        \r\n        node_x, node_y, node_text, node_size = [], [], [], []\r\n        for node in G.nodes():\r\n            x, y = pos[node]\r\n            node_x.append(x)\r\n            node_y.append(y)\r\n            node_text.append(node)\r\n            degree = G.degree(node)\r\n            node_size.append(10 + degree * 5)\r\n        \r\n        node_trace = go.Scatter(\r\n            x=node_x, y=node_y,\r\n            mode='markers+text',\r\n            text=node_text,\r\n            textposition='top center',\r\n            hoverinfo='text',\r\n            marker=dict(\r\n                showscale=True,\r\n                colorscale='YlGnBu',\r\n                color=[G.degree(n) for n in G.nodes()],\r\n                size=node_size,\r\n                colorbar=dict(\r\n                    title='Stopień węzła',\r\n                    thickness=15,\r\n                    xanchor='left',\r\n                    titleside='right'\r\n                ),\r\n                line_width=2\r\n            )\r\n        )\r\n        \r\n        fig = go.Figure(data=[edge_trace, node_trace],\r\n                        layout=go.Layout(\r\n                            title='Sieć przejść między procesami',\r\n                            title_x=0.5,\r\n                            showlegend=False,\r\n                            hovermode='closest',\r\n                            margin=dict(b=0, l=0, r=0, t=40),\r\n                            template='plotly_dark'\r\n                        ))\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres sieci zapisano do pliku: {output_html}"")\r\n        return fig",Narzędzia do wykresów interaktywnych – Opera,opera.exe,18264
2025-10-04 18:36:09,import networkx as nx,Przełączanie zadań,explorer.exe,16892
2025-10-04 18:36:17,networkx,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:37:00,plot_process_network,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:37:32,    fig.show()\r\n,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:38:37,"  File ""c:\Users\trzeb\Desktop\hack\Hackaton\Process_analyse\proc_analysis.py"", line 78, in plot_process_network\r\n    edge_trace = nx.go.Scatter(",Narzędzia do wykresów interaktywnych – Opera,opera.exe,18264
2025-10-04 18:39:19,"  File ""c:\Users\trzeb\Desktop\hack\Hackaton\Process_analyse\proc_analysis.py"", line 78, in plot_process_network\r\n    edge_trace = go.Scatter(",Narzędzia do wykresów interaktywnych – Opera,opera.exe,18264
2025-10-04 18:41:33,titleside,proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:42:59,                    title='right'\r\n,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:48:05,"class ProcessAnalyzer:\r\n    def __init__(self, csv_path: str):\r\n        """"""Inicjalizacja: wczytanie danych z CSV.""""""\r\n        self.data = pd.read_csv(csv_path)\r\n        self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])\r\n        self.data.sort_values(by='timestamp', inplace=True)\r\n    \r\n    def calculate_time_spent(self):\r\n        """"""Liczy czas spędzony w każdym procesie na podstawie różnicy czasów.""""""\r\n        df = self.data.copy()\r\n        df['next_timestamp'] = df['timestamp'].shift(-1)\r\n        df['duration'] = (df['next_timestamp'] - df['timestamp']).fillna(pd.Timedelta(seconds=0))\r\n        \r\n        # Grupowanie po procesach\r\n        time_spent = df.groupby('process')['duration'].sum().reset_index()\r\n        time_spent['minutes'] = time_spent['duration'].dt.total_seconds() / 60\r\n        \r\n        self.time_spent = time_spent\r\n        return time_spent\r\n    \r\n    def plot_time_spent(self, output_html: str = None):\r\n        """"""Tworzy interaktywny wykres Plotly i opcjonalnie zapisuje jako HTML.""""""\r\n        if not hasattr(self, 'time_spent'):\r\n            self.calculate_time_spent()\r\n        \r\n        fig = px.bar(\r\n            self.time_spent,\r\n            x='process',\r\n            y='minutes',\r\n            color='process',\r\n            title='Czas spędzony w poszczególnych procesach (minuty)',\r\n            text_auto='.2f',\r\n        )\r\n        fig.update_layout(\r\n            xaxis_title='Proces',\r\n            yaxis_title='Czas [minuty]',\r\n            showlegend=False,\r\n            template='plotly_dark',\r\n            hovermode='x unified'\r\n        )\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres zapisano do pliku: {output_html}"")\r\n        return fig\r\n    \r\n    def plot_process_network(self, output_html: str = None):\r\n        """"""Tworzy interaktywny wykres sieci przejść między procesami.""""""\r\n        df = self.data.copy()\r\n        df['next_process'] = df['process'].shift(-1)\r\n        \r\n        # usuwamy powtarzające się procesy z rzędu (brak ""przejścia"")\r\n        df = df[df['process'] != df['next_process']]\r\n        \r\n        # liczba przejść między procesami\r\n        transitions = df.groupby(['process', 'next_process']).size().reset_index(name='count')\r\n        \r\n        # budowa grafu NetworkX\r\n        G = nx.DiGraph()\r\n        for _, row in transitions.iterrows():\r\n            G.add_edge(row['process'], row['next_process'], weight=row['count'])\r\n        \r\n        pos = nx.spring_layout(G, seed=42)  # rozmieszczenie węzłów\r\n        \r\n        # przygotowanie danych do Plotly\r\n        edge_x, edge_y = [], []\r\n        for edge in G.edges():\r\n            x0, y0 = pos[edge[0]]\r\n            x1, y1 = pos[edge[1]]\r\n            edge_x.extend([x0, x1, None])\r\n            edge_y.extend([y0, y1, None])\r\n        \r\n        edge_trace = go.Scatter(\r\n            x=edge_x, y=edge_y,\r\n            line=dict(width=1, color='#888'),\r\n            hoverinfo='none',\r\n            mode='lines'\r\n        )\r\n        \r\n        node_x, node_y, node_text, node_size = [], [], [], []\r\n        for node in G.nodes():\r\n            x, y = pos[node]\r\n            node_x.append(x)\r\n            node_y.append(y)\r\n            node_text.append(node)\r\n            degree = G.degree(node)\r\n            node_size.append(10 + degree * 5)\r\n        \r\n        node_trace = go.Scatter(\r\n            x=node_x, y=node_y,\r\n            mode='markers+text',\r\n            text=node_text,\r\n            textposition='top center',\r\n            hoverinfo='text',\r\n            marker=dict(\r\n                showscale=True,\r\n                colorscale='YlGnBu',\r\n                color=[G.degree(n) for n in G.nodes()],\r\n                size=node_size,\r\n                colorbar=dict(\r\n                    title='Stopień węzła',\r\n                    thickness=15,\r\n                    xanchor='left'  \r\n                ),\r\n                line_width=2\r\n            )\r\n        )\r\n        \r\n        fig = go.Figure(data=[edge_trace, node_trace],\r\n                        layout=go.Layout(\r\n                            title='Sieć przejść między procesami',\r\n                            title_x=0.5,\r\n                            showlegend=False,\r\n                            hovermode='closest',\r\n                            margin=dict(b=0, l=0, r=0, t=40),\r\n                            template='plotly_dark'\r\n                        ))\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres sieci zapisano do pliku: {output_html}"")\r\n        return fig",proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:49:51,column,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:54:04,"    def plot_process_network(self, output_html: str = None, column: str = 'process'):\r\n        """"""Tworzy interaktywny wykres sieci przejść między procesami.""""""\r\n        df = self.data.copy()\r\n        df['next_process'] = df[column].shift(-1)\r\n        \r\n        # usuwamy powtarzające się procesy z rzędu (brak ""przejścia"")\r\n        df = df[df[column] != df['next_process']]\r\n        \r\n        # liczba przejść między procesami\r\n        transitions = df.groupby([column, 'next_process']).size().reset_index(name='count')\r\n        \r\n        # budowa grafu NetworkX\r\n        G = nx.DiGraph()\r\n        for _, row in transitions.iterrows():\r\n            G.add_edge(row[column], row['next_process'], weight=row['count'])\r\n        \r\n        pos = nx.spring_layout(G, seed=42)  # rozmieszczenie węzłów\r\n        \r\n        # przygotowanie danych do Plotly\r\n        edge_x, edge_y = [], []\r\n        for edge in G.edges():\r\n            x0, y0 = pos[edge[0]]\r\n            x1, y1 = pos[edge[1]]\r\n            edge_x.extend([x0, x1, None])\r\n            edge_y.extend([y0, y1, None])\r\n        \r\n        edge_trace = go.Scatter(\r\n            x=edge_x, y=edge_y,\r\n            line=dict(width=1, color='#888'),\r\n            hoverinfo='none',\r\n            mode='lines'\r\n        )\r\n        \r\n        node_x, node_y, node_text, node_size = [], [], [], []\r\n        for node in G.nodes():\r\n            x, y = pos[node]\r\n            node_x.append(x)\r\n            node_y.append(y)\r\n            node_text.append(node)\r\n            degree = G.degree(node)\r\n            node_size.append(10 + degree * 5)\r\n        \r\n        node_trace = go.Scatter(\r\n            x=node_x, y=node_y,\r\n            mode='markers+text',\r\n            text=node_text,\r\n            textposition='top center',\r\n            hoverinfo='text',\r\n            marker=dict(\r\n                showscale=True,\r\n                colorscale='YlGnBu',\r\n                color=[G.degree(n) for n in G.nodes()],\r\n                size=node_size,\r\n                colorbar=dict(\r\n                    title='Stopień węzła',\r\n                    thickness=15,\r\n                    xanchor='left'  \r\n                ),\r\n                line_width=2\r\n            )\r\n        )\r\n        \r\n        fig = go.Figure(data=[edge_trace, node_trace],\r\n                        layout=go.Layout(\r\n                            title='Sieć przejść między procesami',\r\n                            title_x=0.5,\r\n                            showlegend=False,\r\n                            hovermode='closest',\r\n                            margin=dict(b=0, l=0, r=0, t=40),\r\n                            template='plotly_dark'\r\n                        ))\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres sieci zapisano do pliku: {output_html}"")\r\n        return fig\r\n",proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:57:15,node_size.append(20 * (1 + degree/max_degree)),proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 18:57:33,max_degree = max(dict(G.degree()).values()),● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:03:06,"    fig = analyzer.plot_process_network(""plotly/siec_titles.html"", 'title')",proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:03:21,"    fig = analyzer.plot_time_spent(""plotly/czas_procesy.html"")\r\n",● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:06:52,'Sieć przejść między procesami' if column == 'process' else 'Sieć przejść między podprocesami',● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:08:55,'process',● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:09:44,"    fig = analyzer.plot_time_spent(""plotly/czas_title.html"", 'title')\r\n",● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:11:03,"import pandas as pd\r\nimport plotly.express as px\r\nimport plotly.graph_objects as go\r\nfrom datetime import timedelta\r\nimport networkx as nx\r\n\r\nclass ProcessAnalyzer:\r\n    def __init__(self, csv_path: str):\r\n        """"""Inicjalizacja: wczytanie danych z CSV.""""""\r\n        self.data = pd.read_csv(csv_path)\r\n        self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])\r\n        self.data.sort_values(by='timestamp', inplace=True)\r\n    \r\n    def calculate_time_spent(self, column: str = 'process') -> pd.DataFrame:\r\n        """"""Liczy czas spędzony w każdym procesie na podstawie różnicy czasów.""""""\r\n        df = self.data.copy()\r\n        df['next_timestamp'] = df['timestamp'].shift(-1)\r\n        df['duration'] = (df['next_timestamp'] - df['timestamp']).fillna(pd.Timedelta(seconds=0))\r\n        \r\n        # Grupowanie po procesach\r\n        time_spent = df.groupby(column)['duration'].sum().reset_index()\r\n        time_spent['minutes'] = time_spent['duration'].dt.total_seconds() / 60\r\n        \r\n        self.time_spent = time_spent\r\n        return time_spent\r\n    \r\n    def plot_time_spent(self, output_html: str = None):\r\n        """"""Tworzy interaktywny wykres Plotly i opcjonalnie zapisuje jako HTML.""""""\r\n        if not hasattr(self, 'time_spent'):\r\n            self.calculate_time_spent()\r\n        \r\n        fig = px.bar(\r\n            self.time_spent,\r\n            x='process',\r\n            y='minutes',\r\n            color='process',\r\n            title='Czas spędzony w poszczególnych procesach (minuty)',\r\n            text_auto='.2f'\r\n        )\r\n        fig.update_layout(\r\n            xaxis_title='Proces',\r\n            yaxis_title='Czas [minuty]',\r\n            showlegend=False,\r\n            template='plotly_dark',\r\n            hovermode='x unified'\r\n        )\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres zapisano do pliku: {output_html}"")\r\n        return fig\r\n    \r\n    def plot_process_network(self, output_html: str = None, column: str = 'process'):\r\n        """"""Tworzy interaktywny wykres sieci przejść między procesami.""""""\r\n        df = self.data.copy()\r\n        df['next_process'] = df[column].shift(-1)\r\n        \r\n        # usuwamy powtarzające się procesy z rzędu (brak ""przejścia"")\r\n        df = df[df[column] != df['next_process']]\r\n        \r\n        # liczba przejść między procesami\r\n        transitions = df.groupby([column, 'next_process']).size().reset_index(name='count')\r\n        \r\n        # budowa grafu NetworkX\r\n        G = nx.DiGraph()\r\n        for _, row in transitions.iterrows():\r\n            G.add_edge(row[column], row['next_process'], weight=row['count'])\r\n        \r\n        pos = nx.spring_layout(G, seed=42)  # rozmieszczenie węzłów\r\n        \r\n        # przygotowanie danych do Plotly\r\n        edge_x, edge_y = [], []\r\n        for edge in G.edges():\r\n            x0, y0 = pos[edge[0]]\r\n            x1, y1 = pos[edge[1]]\r\n            edge_x.extend([x0, x1, None])\r\n            edge_y.extend([y0, y1, None])\r\n        \r\n        edge_trace = go.Scatter(\r\n            x=edge_x, y=edge_y,\r\n            line=dict(width=1, color='#888'),\r\n            hoverinfo='none',\r\n            mode='lines'\r\n        )\r\n        \r\n        node_x, node_y, node_text, node_size = [], [], [], []\r\n        max_degree = max(dict(G.degree()).values())\r\n        for node in G.nodes():\r\n            x, y = pos[node]\r\n            node_x.append(x)\r\n            node_y.append(y)\r\n            node_text.append(node)\r\n            degree = G.degree(node)\r\n            node_size.append(20 * (1 + degree/max_degree))\r\n        \r\n        node_trace = go.Scatter(\r\n            x=node_x, y=node_y,\r\n            mode='markers+text',\r\n            text=node_text,\r\n            textposition='top center',\r\n            hoverinfo='text',\r\n            marker=dict(\r\n                showscale=True,\r\n                colorscale='YlGnBu',\r\n                color=[G.degree(n) for n in G.nodes()],\r\n                size=node_size,\r\n                colorbar=dict(\r\n                    title='Stopień węzła',\r\n                    thickness=15,\r\n                    xanchor='left'  \r\n                ),\r\n                line_width=2\r\n            )\r\n        )\r\n        \r\n        fig = go.Figure(data=[edge_trace, node_trace],\r\n                        layout=go.Layout(\r\n                            title='Sieć przejść między procesami' if column == 'process' else 'Sieć przejść między podprocesami',\r\n                            title_x=0.5,\r\n                            showlegend=False,\r\n                            hovermode='closest',\r\n                            margin=dict(b=0, l=0, r=0, t=40),\r\n                            template='plotly_dark'\r\n                        ))\r\n        \r\n        if output_html:\r\n            fig.write_html(output_html)\r\n            print(f""Wykres sieci zapisano do pliku: {output_html}"")\r\n        return fig\r\n\r\n\r\nif __name__ == ""__main__"":\r\n    analyzer = ProcessAnalyzer(""data/corporate_workflow_data.csv"")\r\n    print(analyzer.calculate_time_spent())\r\n\r\n    fig = analyzer.plot_time_spent(""plotly/czas_procesy.html"")\r\n    fig = analyzer.plot_process_network(""plotly/siec_titles.html"", 'title')\r\n    fig = analyzer.plot_process_network(""plotly/siec_process.html"")\r\n",proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:16:35,"sizemode='diameter',  # tryb skalowania\r\n                sizeref=2 * max(node_size) / (40 ** 2),  # automatyczne skalowanie\r\n                sizemin=6,  # minimalny rozmiar węzła",proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:16:53,autosize=True ,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:18:54,"                sizeref=2 * max(node_size) / (40 ** 2),  # automatyczne skalowanie\r\n",● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:23:40,G.degree(node),proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:24:11,[G.degree(n) for n in G.nodes()],proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:24:54,degree,proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:26:21,degrees,proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:26:40,            node_size.append(20 * (1 + degree/max_degree))\r\n,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:26:41,node_size,● proc_analysis.py - Hackaton - Visual Studio Code,Code.exe,18256
2025-10-04 19:29:40,"<!DOCTYPE html>\r\n<html lang=""en"">\r\n<head>\r\n    <meta charset=""UTF-8"">\r\n    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">\r\n    <title>ProcessBot Analytics</title>\r\n    <script src=""https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js""></script>\r\n    <style>",JSON data file management - Claude – Opera,opera.exe,18264
